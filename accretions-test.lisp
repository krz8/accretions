;;;; tests for the accretions library
(defpackage #:accretions-test
  (:use #:cl #:5am #:accretions)
  (:export #:all #:bag #:tst))

(in-package #:accretions-test)
(def-suite all :description "all accretions tests")

(def-suite bags :description "bags" :in all)
(in-suite bags)

(test make-bag
  (let ((b (make-bag)))
    (is (not (null b)))
    (is (typep b 'acr:bag))))

(test (emptyp :depends-on make-bag)
  (let ((b (make-bag)))
    (is (emptyp b))
    (push 123 (acr::items b))		; haven't tested add yet
    (is (not (emptyp b)))))

(defmacro with-bag ((name) &body body)
  `(let ((,name (make-bag)))
     (is-true (add 'a ,name))
     (is-true (add 3 ,name))
     (is-true (add t ,name))
     (is-true (add nil ,name))
     (is-true (add "foobar" ,name))
     ,@body))

(test (add :depends-on make-bag)
  (with-bag (b)
    (let ((l (acr::items b)))
      (is (equal (car l) "foobar"))
      (is (null (cadr l)))
      (is (eq (caddr l) t))
      (is (= (cadddr l) 3))
      (is (eq (car (cddddr l)) 'a))
      (is (null (cdr (cddddr l)))))))

(test (mapfun :depends-on make-bag)
  (let ((b (make-bag))
	(n 0))
    (mapfun (lambda (x)
	      (declare (ignore x))
	      (incf n))
	    b)
    (is (zerop n)))
  (with-bag (b)
    (let (r)
      (mapfun (lambda (x) (push x r)) b)
      (is (= (length r) 5))
      (is (equalp r '(a 3 t nil "foobar"))))))

;; Why doesn't this test generate output? It definitely runs; if
;; "foobar" becomes "xfoobar" the test fails.  But there are no
;; progress dots reported.  Weird.

(test (make-iterator :depends-on make-bag)
  (with-bag (b)
    (let ((f (make-iterator b))
	  values statuses)
      (dotimes (i 6)
	(multiple-value-bind (x y) (funcall f)
	  (push x values)
	  (push y statuses)))
      (is (equalp values '(nil a 3 t nil "foobar")))
      (is (equalp statuses '(nil t t t t t)))
      (is-true (funcall f :reset))
      (multiple-value-bind (x y) (funcall f :peek)
	(is (equal "foobar" x))
	(is (eq t y)))
      (multiple-value-bind (x y) (funcall f)
	(is (equal "foobar" x))
	(is (eq t y)))
      (multiple-value-bind (x y) (funcall f :peek)
	(is (null x))
	(is (eq t y)))
      (multiple-value-bind (x y) (funcall f)
	(is (null x))
	(is (eq t y)))
      (multiple-value-bind (x y) (funcall f :peek)
	(is (eq t x))
	(is (eq t y))))))

(test (with-iterator :depends-on make-iterator)
  (with-bag (b)
    (with-iterator (foo b)
      (let (r)
	(push (foo) r)
	(push (foo) r)
	(push (foo) r)
	(foo :reset)
	(push (foo) r)
	(is (equalp r '("foobar" t nil "foobar")))))))

(test (contains :depends-on with-iterator)
  (with-bag (b)
    (is-true (contains "foobar" b))
    (is-true (contains nil b))
    (is-true (contains t b))
    (is-true (contains 3 b))
    (is-true (contains 'a b))
    (is-false (contains "FOOBAR" b))
    (is-false (contains 2 b))
    (is-false (contains 'b b))
    (is-false (contains "foobar" b :test #'eq))
    (is-false (contains "foobar" b :test #'eql))
    (is-true (contains "foobar" b :test #'equal))
    (is-true (contains "foobar" b :test #'equalp))
    ;; Under CCL, numbers compare even with EQ.
    #-ccl (is-false (contains 3 b :test #'eq))
    (is-true (contains 3 b :test #'eql))
    (is-true (contains 3 b :test #'equal))
    (is-true (contains 3 b :test #'equalp))))

(def-suite tst :description "ternary search trees" :in all)
(in-suite tst)
